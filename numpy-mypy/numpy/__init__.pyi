from typing import (Any, Callable, Dict, Generic, Iterator, List, Optional, Sequence, Tuple, Type,
                    TypeVar, Union)

class dtype: ...
_dtype = dtype


class flagsobj:
    aligned = None       # type: bool
    behaved = None       # type: bool
    c_contiguous = None  # type: bool
    carray = None        # type: bool
    contiguous = None    # type: bool
    f_contiguous = None  # type: bool
    farray = None        # type: bool
    fnc = None           # type: bool
    forc = None          # type: bool
    fortran = None       # type: bool
    owndata = None       # type: bool
    updateifcopy = None  # type: bool
    writeable = None     # type: bool
    def __getitem__(self, item: str) -> bool: ...


# TODO Complete scalar hierarchy
class generic: ...  # TODO add generic fields and methods
class bool_(generic): ...
bool8 = bool_
class object_(generic): ...
class number(generic): ...
class integer(number): ...
class signedinteger(integer): ...
class byte(signedinteger): ...
class short(signedinteger): ...
class intc(signedinteger): ...
class int_(signedinteger): ...
class longlong(signedinteger): ...
class int8(signedinteger): ...
class int16(signedinteger): ...
class int32(signedinteger): ...
class int64(signedinteger): ...
class unsignedinteger(integer): ...
class ubyte(unsignedinteger): ...
class ushort(unsignedinteger): ...
class uintc(unsignedinteger): ...
class uint(unsignedinteger): ...
class ulonglong(unsignedinteger): ...
class uint8(signedinteger): ...
class uint16(signedinteger): ...
class uint32(signedinteger): ...
class uint64(signedinteger): ...
class inexact(number): ...
class floating(inexact): ...
class half(floating): ...
class single(floating): ...
class float_(floating): ...
class longfloat_(floating): ...
class float16(floating): ...
class float32(floating): ...
class float64(floating): ...
class float128(floating): ...
class complextfloating(inexact): ...
class csingle(complextfloating): ...
class complex_(complextfloating): ...
class clongfloat(complextfloating): ...
class complex64(complextfloating): ...
class complex128(complextfloating): ...
class complex256(complextfloating): ...
class flexible(generic): ...
class character(flexible): ...
class str_(character): ...
class unicode_(character): ...
class void(flexible): ...

AxesType = Union[int, Tuple[int, ...]]
DtypeType = Union[dtype, type]
ShapeType = Union[int, Tuple[int, ...]]
NdarrayLikeType = TypeVar('NdarrayLikeType', bound='ndarray')

S = TypeVar('S')
U = TypeVar('U')
V = TypeVar('V')

class ndarray(Generic[S]):
    T = None         # type: ndarray
    data = None      # type: Any
    dtype = None     # type: _dtype
    flags = None     # type: flagsobj
    flat = None      # type: Iterator[Any]  # TODO Find out if there's a way to restrict the type argument
    imag = None      # type: ndarray
    real = None      # type: ndarray
    size = None      # type: int
    itemsize = None  # type: int
    nbytes = None    # type: int
    ndim = None      # type: int
    shape = None     # type: Tuple[int, ...]
    strides = None   # type: Tuple[int, ...]
    ctypes = None    # type: Any  # TODO Implement ctypes type hint
    base = None      # type: Optional[ndarray]

    # TODO Need to find a way to restrict buffer type
    def __init__(self, shape: Tuple[int, ...], dtype: Optional[DtypeType]=None,
                 buffer: Optional[Any]=None, offset: Optional[int]=None,
                 strides: Optional[Tuple[int, ...]]=None, order: Optional[str]=None) -> None: ...

    def __abs__(self) -> 'ndarray[S]': ...

    def __add__(self, value: Any) -> 'ndarray[Any]': ...

    def __and__(self, value: Any) -> bool: ...

    def __bool__(self) -> bool: ...

    def __complex__(self) -> complex: ...

    def __contains__(self, value: Any) -> bool: ...

    def __copy__(self) -> 'ndarray[S]': ...

    def __deepcopy__(self) -> 'ndarray[S]': ...

    def __delattr__(self, name: str) -> None: ...

    def __delitem__(self, key: str) -> None: ...

    def __dir__(self) -> List[str]: ...

    def __divmod__(self, value: Any) -> 'ndarray[Any]': ...

    def __eq__(self, value: Any) -> 'ndarray[bool]': ...  # type: ignore

    def __float__(self) -> float: ...

    def __floordiv__(self, value: Any) -> 'ndarray[int]': ...

    def __ge__(self, value: Any) -> 'ndarray[bool]': ...

    def __getattribute__(self, name: str) -> Any: ...

    def __getitem__(self, key: str) -> Any: ...

    def __gt__(self, value: Any) -> 'ndarray[bool]': ...

    def __iadd__(self, value: Any) -> None: ...

    def __iand__(self, value: Any) -> None: ...

    def __ifloordiv__(self, value: Any) -> None: ...

    def __ilshift__(self, value: Any) -> None: ...

    def __imatmul__(self, value: 'ndarray[U]') -> None: ...

    def __imod__(self, value: Any) -> None: ...

    def __imul__(self, value: Any) -> None: ...

    def __index__(self) -> int: ...

    def __int__(self) -> int: ...

    def __invert__(self) -> 'ndarray[S]': ...

    def __ior__(self, value: Any) -> None: ...

    def __ipow__(self, value: Any) -> None: ...

    def __irshift__(self, value: Any) -> None: ...

    def __isub__(self, value: Any) -> None: ...

    def __iter__(self) -> Iterator[S]: ...

    def __itruediv__(sel, value: Any) -> None: ...

    def __ixor__(self, value: Any) -> None: ...

    def __le__(self, value: Any) -> 'ndarray[bool]': ...

    def __len__(self) -> int: ...

    def __lshift__(self, value: Any) -> 'ndarray[S]': ...

    def __lt__(self, value: Any) -> 'ndarray[bool]': ...

    def __matmul__(self, value: 'ndarray[U]') -> 'ndarray[Any]': ...

    def __mod__(self, value: Any) -> 'ndarray[S]': ...

    def __mul__(self, value: Any) -> 'ndarray[Any]': ...

    def __ne__(self, value: Any) -> 'ndarray[bool]': ...  # type: ignore

    def __neg__(self) -> 'ndarray[S]': ...

    def __or__(self, value: Any) -> 'ndarray[bool]': ...

    def __pos__(self) -> 'ndarray[S]': ...

    def __pow__(self, value: Any) -> 'ndarray[Any]': ...

    def __radd__(self, value: Any) -> 'ndarray[Any]': ...

    def __rand__(self, value: Any) -> 'ndarray[bool]': ...

    def __rdivmod__(self, value: Any) -> 'ndarray[Any]': ...

    def __reduce__(self) -> None: ...

    def __reduce_ex__(self) -> None: ...

    def __repr__(self) -> str: ...

    def __rfloordiv__(self, value: Any) -> 'ndarray[Any]': ...

    def __rlshift__(self, value: Any) -> 'ndarray[Any]': ...

    def __rmatmul__(self, value: Any) -> 'ndarray[Any]': ...

    def __rmod__(self, value: Any) -> 'ndarray[Any]': ...

    def __rmul__(self, value: Any) -> 'ndarray[Any]': ...

    def __ror__(self, value: Any) -> 'ndarray[bool]': ...

    def __rpow__(self, value: Any) -> 'ndarray[Any]': ...

    def __rrshift__(self, value: Any) -> 'ndarray[Any]': ...

    def __rshift__(self, value: Any) -> 'ndarray[Any]': ...

    def __rsub__(self, value: Any) -> 'ndarray[Any]': ...

    def __rtruediv__(self, value: Any) -> 'ndarray[Any]': ...

    def __rxor__(self, value: Any) -> 'ndarray[bool]': ...

    def __setattr__(self, name: str, value: Any) -> None: ...

    def __setitem__(self, key: Any, value: Any) -> None: ...

    def __setstate__(self, state: Any) -> None: ...

    def __sizeof__(self) -> int: ...

    def __str__(self) -> str: ...

    def __sub__(self, value: Any) -> 'ndarray[Any]': ...

    def __subclasshook__(self, *args: Any, **kwargs: Any) -> Any: ...  # TODO define __subclasshook__

    def __truediv__(sel, value: Any) -> 'ndarray[bool]': ...

    def __xor__(self, value: Any) -> 'ndarray[bool]': ...

    def all(self, axis: Optional[AxesType]=None, out: Optional['ndarray[U]']=None,
            keepdims: Optional[bool]=None) -> Union['ndarray[U]', 'ndarray[bool]', bool]: ...

    def any(self, axis: Optional[AxesType]=None, out: Optional['ndarray[U]']=None,
            keepdims: Optional[bool]=None) -> Union['ndarray[U]', 'ndarray[bool]', bool]: ...

    def argmax(self, axis: Optional[int]=None,
               out: Optional['ndarray[U]']=None) -> Union['ndarray[U]', 'ndarray[int]', int]: ...

    def argmin(self, axis: Optional[int]=None,
               out: Optional['ndarray[U]']=None) -> Union['ndarray[U]', 'ndarray[int]', int]: ...

    def argpartition(self, kth: Union[int, Sequence[int]], axis: Optional[int]=-1,
                     kind: Optional[str]='introselect',
                     order: Optional[Union[str, List[str]]]=None) -> 'ndarray[int]': ...

    def argsort(self, axis: Optional[int]=None, kind: Optional[str]='quicksort',
                order: Optional[Union[str, List[str]]]=None) -> 'ndarray[int]': ...

    def astype(self, dtype: Any, order: Optional[str]='K',
               casting: Optional[str]='unsafe', subok: Optional[bool]=None,
               copy: Optional[bool]=None) -> 'ndarray[Any]': ...

    def byteswap(self, inplace: Optional[bool]=False) -> 'ndarray[S]': ...

    def choose(self, choices:Sequence['ndarray[Any]'], out: Optional['ndarray[Any]']=None,
               mode: Optional['str']='raise') -> 'ndarray[Any]': ...

    def clip(self, a_min: Any, a_max: Any,
             out: Optional['ndarray[U]']=None) -> Union['ndarray[S]', 'ndarray[U]']: ...

    def compress(self, condition: Sequence[bool], axis: Optional[int]=None,
                 out: Optional['ndarray[U]']=None) -> Union['ndarray[S]', 'ndarray[U]']: ...

    def conj(self) -> 'ndarray[S]': ...

    def conjugate(self) -> 'ndarray[S]': ...

    def copy(self, order: Optional['str']='C') -> 'ndarray[S]': ...

    def cumprod(self, axis: Optional[int]=None, dtype: Optional[Any]=None,
                out: Optional['ndarray[Any]']=None) -> 'ndarray[Any]': ...

    def cumsum(self, axis: Optional[int]=None, dtype: Optional[Any]=None,
                out: Optional['ndarray[Any]']=None) -> 'ndarray[Any]': ...

    def diagonal(self, offset: Optional[int]=0, axis1: Optional[int]=0,
                 axis2: Optional[int]=1) -> 'ndarray[S]': ...

    def dot(self, b: 'ndarray[Any]',
            out: Optional['ndarray[Any]']=None) -> 'ndarray[Any]': ...

    def dump(self, file: 'str') -> None: ...

    def dumps(self) -> 'str': ...

    def fill(self, value: Any) -> None: ...

    def flatten(self, order: Optional[str]='C') -> 'ndarray[S]': ...

    def getfield(self, dtype: Any, offset: Optional[int]=0) -> 'ndarray[Any]': ...

    def item(self, args: Optional[AxesType]) -> generic: ...

    def itemset(self, arg0: Union[int, Tuple[int, ...]], arg1: Optional[generic]=None) -> None: ...

    def max(self, axis: Optional[AxesType]=None,
            out: Optional['ndarray[U]']=None) -> Union['ndarray[S]', 'ndarray[U]', generic]: ...

    def mean(self, axis: Optional[AxesType]=None, dtype: Optional[Any]=None,
             out=Optional['ndarray[U]'], keepdims: Optional[bool]=False) -> 'ndarray[Any]': ...

    def min(self, axis: Optional[AxesType]=None,
            out: Optional['ndarray[U]']=None) -> Union['ndarray[S]', 'ndarray[U]', generic]: ...

    def newbyteorder(self, new_order: Optional['str']='S') -> 'ndarray[Any]': ...

    def nonzero(self) -> 'ndarray[int]': ...

    def partition(self, kth: AxesType, axis: Optional[int]=-1, kind: Optional[str]='introselect',
                  order: Optional[Union[Sequence[str], str]]=None) -> None: ...

    def prod(self, axis: Optional[AxesType]=None, dtype: Optional[Any]=None,
             out: Optional['ndarray[U]']=None, keepdims: Optional[bool]=False) -> 'ndarray[Any]': ...

    def ptp(self, axis: Optional[int]=None,
            out: Optional['ndarray[U]']=None) -> Union['ndarray[S]', 'ndarray[U]']: ...

    def put(self, ind: Sequence[Any], v: Sequence[Any], mode: Optional[str]='raise') -> None: ...

    def ravel(self, order: Optional[str]='C') -> 'ndarray[S]': ...

    def repeat(self, repeats: Union[int, Sequence[int]],
               axis: Optional[int]=None) -> 'ndarray[S]': ...

    def reshape(self, newshape: ShapeType,
                order: Optional[str]='C') -> 'ndarray[S]': ...

    def resize(self, new_shape: ShapeType, refcheck: Optional[bool]=True) -> None: ...

    def round(self, decimals: int=0,
              out: Optional['ndarray[U]']=None) -> Union['ndarray[S]', 'ndarray[U]']: ...

    def searchsorted(self, v: Union[Any, Sequence[Any]], side: Optional[str]='left',
                     sorter: Optional[Any]=None) -> 'ndarray[int]': ...

    def setfield(self, val: Any, dtype: Any, offset: Optional[int]=0) -> None: ...

    def setflags(self, write: Optional[bool]=None, align: Optional[bool]=None,
                 uic: Optional[bool]=None) -> None: ...

    def sort(self, axis: Optional[int]=-1, kind: Optional[str]='quicksort',
             order: Optional[Union[str, Sequence[str]]]=None) -> None: ...

    def squeeze(self, axis: Optional[AxesType]) -> 'ndarray[S]': ...

    def std(self, axis: Optional[AxesType]=None, dtype=Optional[DtypeType],
            out=Optional['ndarray[U]'], ddof: Optional[int]=0,
            keepdims: Optional[bool]=False) -> 'ndarray[Any]': ...

    def sum(self, axis: Optional[AxesType]=None, dtype=Optional[DtypeType],
            out: Optional['ndarray[U]']=None, keepdims: Optional[bool]=False) -> 'ndarray[Any]': ...

    def swapaxes(self, axis1: int, axis2: int) -> 'ndarray[S]': ...

    def take(self, indices: Sequence[int], axis: Optional[int]=None,
             out: Optional['ndarray[U]']=None,
             mode: Optional[str]='raise') -> Union['ndarray[U]', 'ndarray[S]']: ...

    def tobytes(self, order: Optional[str]='C') -> bytes: ...

    def tofile(self, fid: Any, sep: Optional[str]='',  # TODO fix fid definition (There's a bug in mypy io's namespace https://github.com/python/mypy/issues/1462)
               format: Optional[str]='%s') -> None: ...

    def tolist(self) -> List[Any]: ...

    def tostring(self, order: Optional[str]='C') -> bytes: ...

    def trace(self, offset: Optional[int]=0, axis1: Optional[int]=0, axis2: Optional[int]=1,
              dtype=Optional[DtypeType], out=Optional['ndarray[U]']) -> 'ndarray[Any]': ...

    def transpose(self, args0: Optional[Union[int, Tuple[int]]], *args: int) -> 'ndarray[S]': ...

    def var(self, axis: Optional[AxesType]=None, dtype=Optional[DtypeType], out=Optional['ndarray[U]'],
            ddof: Optional[int]=0, keepdims: Optional[bool]=False) -> 'ndarray[S]': ...

    def view(self, dtype: Optional[Union[DtypeType, Type[NdarrayLikeType]]]=None,
             type: Optional[type]=None) -> 'ndarray[Any]': ...

# Array creation routines

def array(object: Any, dtype: Optional[Any]=None, copy: Optional[bool]=True,
          order: Optional[str]=None, subok: Optional[bool]=False,
          ndmin: Optional[int]=0) -> ndarray[Any]: ...
def asarray(a: Any, dtype: Optional[DtypeType]=None, order: Optional[str]=None) -> ndarray[Any]: ...
def asanyarray(a: Any, dtype: Optional[DtypeType]=None, order: Optional[str]=None) -> ndarray[Any]: ...  # TODO figure out a way to restrict the return type
def asmatrix(data: Any, dtype: Optional[DtypeType]=None) -> Any: ...  # TODO define matrix
def ascontiguousarray(a: Any, dtype: Optional[DtypeType]=None) -> ndarray[Any]: ...
def copy(a: Any, order: Optional[str]=None)	-> ndarray[Any]: ...
def empty(shape: ShapeType, dtype: Optional[DtypeType]=float, order: Optional[str]='C') -> ndarray[Any]: ...
def empty_like(a: Any, dtype: Optional[Any]=None, order: Optional[str]='K',
               subok: Optional[bool]=True) -> ndarray[Any]: ...
def eye(N: int, M: Optional[int]=None, k=0, dtype: Optional[DtypeType]=float) -> ndarray[Any]: ...

def frombuffer(buffer: Any, dtype: Optional[DtypeType]=float, count: Optional[int]=-1,  # TODO figure out a way to restrict buffer
               offset: Optional[int]=0) -> ndarray[Any]: ...
def fromfile(file: Any, dtype: Optional[DtypeType]=float, count: Optional[int]=-1,
             sep: Optional['str']='') -> ndarray[Any]: ...  # TODO fix file definition (There's a bug in mypy io's namespace https://github.com/python/mypy/issues/1462)
def full(shape: ShapeType, fill_value: Any, dtype: Optional[DtypeType]=None,
         order: Optional[str]='C') -> ndarray[Any]: ...
def full_like(a: Any, fill_value: Any, dtype: Optional[DtypeType]=None, order: Optional[str]='C',
              subok: Optional[bool]=True) -> ndarray[Any]: ...
def fromfunction(function: Callable[..., S], shape: ShapeType, dtype: Optional[DtypeType]=float) -> ndarray[S]: ...
def fromiter(iterable: Iterator[Any], dytpe: DtypeType, count: Optional[int]=-1) -> ndarray[Any]: ...
def fromstring(string: str, dtype: Optional[DtypeType]=float, count: Optional[int]=-1,
               sep: Optional[str]='') -> ndarray[Any]: ...
def identity(n: int, dtype: Optional[DtypeType]=None) -> ndarray[Any]: ...
def loadtxt(fname: Any, dtype: Optional[DtypeType]=float, comments: Optional[str]='#',
            delimiter: Optional[str]=None, converters=Optional[Dict[int, Callable[Any, float]]],
            skiprows: Optional[int]=0, usecols: Optional[Sequence[int]]=None,
            unpack: Optional[bool]=False, ndmin: Optional[int]=0) -> ndarray[float]: ...
def ones(shape: ShapeType, dtype: Optional[DtypeType]=float, order: Optional[str]='C') -> ndarray[Any]: ...
def ones_like(a: Any, dtype: Optional[Any]=None, order: Optional[str]='K',
              subok: Optional[bool]=True) -> ndarray[Any]: ...
def zeros(shape: ShapeType, dtype: Optional[DtypeType]=float, order: Optional[str]='C') -> ndarray[Any]: ...
def zeros_like(a: Any, dtype: Optional[Any]=None, order: Optional[str]='K',
               subok: Optional[bool]=True) -> ndarray[Any]: ...
